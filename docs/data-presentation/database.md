---
sidebar_position: 8
---

# Database Storage: Prisma ORM with SQLite

## Overview

As our dataset grew in complexity with keyword tags and job relationships, we transitioned from simple CSV files to a structured database using Prisma ORM with SQLite. This decision was driven by the need to handle job-keyword associations, maintain data integrity, and provide type-safe database operations for our dashboard.

## Database Design Rationale

### Why Prisma ORM Over Direct SQL

#### Complexity Limitations of Raw SQL

- **Type safety**: No compile-time guarantees for queries and data structures
- **Boilerplate code**: Repetitive SQL string construction and parameter binding
- **Migration management**: Manual schema versioning and deployment
- **Relationship complexity**: Manual handling of foreign keys and joins
- **Error handling**: Runtime SQL errors without type checking

#### Prisma Advantages

- **Type safety**: Generated TypeScript types for all database operations
- **Intuitive API**: Fluent query builder with auto-completion
- **Schema-first approach**: Single source of truth for database schema
- **Automatic migrations**: Version-controlled database schema changes
- **Relationship handling**: Built-in support for complex queries and joins
- **SQLite compatibility**: Lightweight, file-based database perfect for development and small-scale deployment

## Database Schema Design

### Prisma Schema Structure

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL") // e.g., "file:./jobs_data.db"
}

// --------------------------------------------------------
// JOB MODEL
// Mapped to the 'jobs' table generated by pandas
// --------------------------------------------------------

model Job {
  id              String   @id @map("job_id") // The MD5 Hash

  // Basic Info
  link            String   @map("jobLink-href")
  title           String
  company         String
  location        String
  type            String   @map("jobType")         // e.g. "Feste Anstellung"
  workArrangement String   @map("workArrangement") // e.g. "Vollzeit"
  datePosted      String   @map("posted")

  // Content
  description     String
  logoUrl         String?  @map("logo-src")
  salary          String?
  industry        String?  @map("branche")

  // Boolean Flags (SQLite stores these as 0/1, Prisma handles conversion)
  isPartTime          Boolean @map("part_time")
  noExperience        Boolean @map("no_experience")
  isManagement        Boolean @map("management")
  isFullHomeOffice    Boolean @map("homeoffice_full")
  isPartialHomeOffice Boolean @map("homeoffice_partial")

  // Relationships
  tags JobTag[]

  @@map("jobs")
}

// --------------------------------------------------------
// TAG MODEL
// Mapped to the 'tags' table containing your Hierarchy
// --------------------------------------------------------

model Tag {
  id        Int    @id @default(autoincrement()) @map("tag_id")
  name      String @map("tag_name")   // e.g. "python"
  category  String                    // e.g. "Tech Stack"
  group     String @map("group_name") // e.g. "Languages & Frameworks"

  // Relationships
  jobs JobTag[]

  @@map("tags")
}

// --------------------------------------------------------
// JUNCTION TABLE (Explicit Many-to-Many)
// Mapped to the 'job_tags' table
// --------------------------------------------------------

model JobTag {
  jobId String @map("job_id")
  tagId Int    @map("tag_id")

  // Foreign Keys
  job Job @relation(fields: [jobId], references: [id], onDelete: Cascade)
  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([jobId, tagId]) // Composite Primary Key for performance
  @@map("job_tags")
}
```

## Database Implementation

### Prisma Client Setup

```typescript
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient({
  log: ["query", "info", "warn", "error"],
});
```

### TypeScript Database Operations

```typescript
import { PrismaClient, Job, Tag } from "@prisma/client";
import { hash } from "crypto";

export class JobMarketDatabase {
  constructor(private prisma: PrismaClient) {}

  async createJobFromData(jobData: any): Promise<Job> {
    // Generate MD5 hash for job ID
    const jobId = hash("md5", jobData.link || jobData.title + jobData.company);

    return await this.prisma.job.upsert({
      where: { id: jobId },
      update: {},
      create: {
        id: jobId,
        link: jobData.link || jobData["jobLink-href"],
        title: jobData.title,
        company: jobData.company,
        location: jobData.location,
        type: jobData.type || jobData.jobType,
        workArrangement: jobData.workArrangement,
        datePosted: jobData.datePosted || jobData.posted,
        description: jobData.description,
        logoUrl: jobData.logoUrl || jobData["logo-src"],
        salary: jobData.salary,
        industry: jobData.industry || jobData.branche,
        isPartTime: Boolean(jobData.isPartTime || jobData.part_time),
        noExperience: Boolean(jobData.noExperience || jobData.no_experience),
        isManagement: Boolean(jobData.isManagement || jobData.management),
        isFullHomeOffice: Boolean(
          jobData.isFullHomeOffice || jobData.homeoffice_full
        ),
        isPartialHomeOffice: Boolean(
          jobData.isPartialHomeOffice || jobData.homeoffice_partial
        ),
      },
    });
  }

  async createOrFindTag(
    name: string,
    category: string,
    group: string
  ): Promise<Tag> {
    return await this.prisma.tag.upsert({
      where: { id: hash("md5", name + category + group) }, // Simple ID generation
      update: {},
      create: {
        name,
        category,
        group,
      },
    });
  }

  async associateJobWithTags(jobId: string, tagNames: string[]): Promise<void> {
    // First, get or create tags
    const tags = await Promise.all(
      tagNames.map((name) => this.createOrFindTag(name, "Unknown", "General"))
    );

    // Create associations
    await this.prisma.jobTag.createMany({
      data: tags.map((tag) => ({
        jobId,
        tagId: tag.id,
      })),
      skipDuplicates: true,
    });
  }

  async findJobsByTags(
    tagNames: string[],
    options?: {
      workArrangement?: string;
      location?: string;
      limit?: number;
    }
  ): Promise<Job[]> {
    const { workArrangement, location, limit = 50 } = options || {};

    return await this.prisma.job.findMany({
      where: {
        AND: [
          workArrangement ? { workArrangement } : {},
          location ? { location: { contains: location } } : {},
          {
            tags: {
              some: {
                tag: {
                  name: { in: tagNames },
                },
              },
            },
          },
        ],
      },
      include: {
        tags: {
          include: {
            tag: true,
          },
        },
      },
      orderBy: [{ tags: { _count: "desc" } }, { title: "asc" }],
      take: limit,
    });
  }

  async getJobsWithTagCounts(): Promise<Array<Job & { tagCount: number }>> {
    return await this.prisma.job
      .findMany({
        include: {
          _count: {
            select: { tags: true },
          },
          tags: {
            include: {
              tag: true,
            },
          },
        },
      })
      .then((jobs) =>
        jobs.map((job) => ({
          ...job,
          tagCount: job._count.tags,
        }))
      );
  }

  async getTagStatistics(): Promise<
    Array<{
      tag: Tag;
      jobCount: number;
    }>
  > {
    return await this.prisma.tag
      .findMany({
        include: {
          _count: {
            select: { jobs: true },
          },
        },
      })
      .then((tags) =>
        tags
          .map((tag) => ({
            tag,
            jobCount: tag._count.jobs,
          }))
          .sort((a, b) => b.jobCount - a.jobCount)
      );
  }

  async getJobsByWorkArrangement(): Promise<
    Array<{
      workArrangement: string;
      count: number;
      avgSalary?: number;
    }>
  > {
    const result = await this.prisma.job.groupBy({
      by: ["workArrangement"],
      _count: { id: true },
      _avg: {
        salary: true, // This might need adjustment based on salary field type
      },
    });

    return result.map((item) => ({
      workArrangement: item.workArrangement,
      count: item._count.id,
      avgSalary: item._avg.salary || undefined,
    }));
  }
}
```

## Database Optimization

### Prisma Migration Management

```bash
# Initialize Prisma in your project
npx prisma init

# Generate Prisma client after schema changes
npx prisma generate

# Create and apply migrations
npx prisma migrate dev --name init

# Reset database in development
npx prisma migrate reset

# View database in Prisma Studio
npx prisma studio
```

### Database Seeding Script

```typescript
import { PrismaClient } from "@prisma/client";
import { JobMarketDatabase } from "./database";
import * as fs from "fs";
import * as path from "path";

async function seedDatabase() {
  const prisma = new PrismaClient();
  const db = new JobMarketDatabase(prisma);

  try {
    console.log("ðŸŒ± Starting database seeding...");

    // Read processed job data (assuming CSV format from pandas)
    const jobsData = JSON.parse(
      fs.readFileSync("./data/jobs_processed.json", "utf-8")
    );
    const tagsData = JSON.parse(
      fs.readFileSync("./data/tags_hierarchy.json", "utf-8")
    );
    const jobTagsData = JSON.parse(
      fs.readFileSync("./data/job_tags.json", "utf-8")
    );

    // Create jobs in batches
    let jobsCreated = 0;
    for (const jobData of jobsData) {
      await db.createJobFromData(jobData);
      jobsCreated++;
      if (jobsCreated % 100 === 0) {
        console.log(`âœ“ Created ${jobsCreated} jobs...`);
      }
    }

    // Create tags
    let tagsCreated = 0;
    for (const tagData of tagsData) {
      await db.createOrFindTag(tagData.name, tagData.category, tagData.group);
      tagsCreated++;
    }
    console.log(`âœ“ Created ${tagsCreated} tags`);

    // Create job-tag associations
    let associationsCreated = 0;
    for (const association of jobTagsData) {
      const tagNames = Array.isArray(association.tags)
        ? association.tags
        : [association.tags];

      await db.associateJobWithTags(association.jobId, tagNames);
      associationsCreated++;
    }
    console.log(`âœ“ Created ${associationsCreated} job-tag associations`);

    console.log("âœ… Database seeding complete!");
  } catch (error) {
    console.error("âŒ Error seeding database:", error);
    throw error;
  } finally {
    await prisma.$disconnect();
  }
}

// Run seeding
seedDatabase().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

### Data Import from Pandas

```python
import pandas as pd
import json
import sqlite3
from pathlib import Path

def export_pandas_to_json(jobs_df: pd.DataFrame, tags_df: pd.DataFrame, job_tags_df: pd.DataFrame):
    """
    Export pandas DataFrames to JSON format for Prisma seeding.
    """

    # Convert jobs DataFrame to records
    jobs_records = []
    for _, row in jobs_df.iterrows():
        job_dict = {
            'link': row.get('jobLink-href', ''),
            'title': row.get('title', ''),
            'company': row.get('company', ''),
            'location': row.get('location', ''),
            'type': row.get('jobType', ''),
            'workArrangement': row.get('workArrangement', ''),
            'datePosted': row.get('posted', ''),
            'description': row.get('description', ''),
            'logoUrl': row.get('logo-src'),
            'salary': row.get('salary'),
            'industry': row.get('branche'),
            'isPartTime': bool(row.get('part_time', False)),
            'noExperience': bool(row.get('no_experience', False)),
            'isManagement': bool(row.get('management', False)),
            'isFullHomeOffice': bool(row.get('homeoffice_full', False)),
            'isPartialHomeOffice': bool(row.get('homeoffice_partial', False)),
        }
        jobs_records.append(job_dict)

    # Convert tags DataFrame to records
    tags_records = []
    for _, row in tags_df.iterrows():
        tag_dict = {
            'name': row.get('tag_name', ''),
            'category': row.get('category', 'General'),
            'group': row.get('group_name', 'General'),
        }
        tags_records.append(tag_dict)

    # Convert job-tags relationships
    job_tags_records = []
    for _, row in job_tags_df.iterrows():
        association = {
            'jobId': row.get('job_id', ''),
            'tags': row.get('tags', []) if isinstance(row.get('tags'), list) else [row.get('tags', '')]
        }
        job_tags_records.append(association)

    # Create data directory
    data_dir = Path('./prisma/data')
    data_dir.mkdir(parents=True, exist_ok=True)

    # Export to JSON files
    with open(data_dir / 'jobs_processed.json', 'w', encoding='utf-8') as f:
        json.dump(jobs_records, f, ensure_ascii=False, indent=2)

    with open(data_dir / 'tags_hierarchy.json', 'w', encoding='utf-8') as f:
        json.dump(tags_records, f, ensure_ascii=False, indent=2)

    with open(data_dir / 'job_tags.json', 'w', encoding='utf-8') as f:
        json.dump(job_tags_records, f, ensure_ascii=False, indent=2)

    print(f"âœ“ Exported {len(jobs_records)} jobs")
    print(f"âœ“ Exported {len(tags_records)} tags")
    print(f"âœ“ Exported {len(job_tags_records)} job-tag associations")

# Export data for Prisma seeding
export_pandas_to_json(jobs_df, tags_df, job_tags_df)
```

## Query Performance and Analytics

### Dashboard Query Examples

```typescript
interface MarketInsights {
  topTags: Array<{
    tag: Tag;
    jobCount: number;
    avgSalary?: number;
  }>;
  workArrangementStats: Array<{
    workArrangement: string;
    count: number;
    jobs: Job[];
  }>;
  locationStats: Array<{
    location: string;
    count: number;
    jobs: Job[];
  }>;
  industryStats: Array<{
    industry: string;
    count: number;
    jobs: Job[];
  }>;
}

export async function getMarketInsights(
  db: JobMarketDatabase
): Promise<MarketInsights> {
  // Top tags by demand
  const topTags = await db
    .getTagStatistics()
    .then((stats) => stats.slice(0, 20));

  // Work arrangement distribution
  const workArrangementStats = await db.prisma.job
    .groupBy({
      by: ["workArrangement"],
      _count: { id: true },
      orderBy: { _count: { id: "desc" } },
    })
    .then((groups) =>
      Promise.all(
        groups.map(async (group) => ({
          workArrangement: group.workArrangement,
          count: group._count.id,
          jobs: await db.prisma.job.findMany({
            where: { workArrangement: group.workArrangement },
            take: 5,
            orderBy: { title: "asc" },
          }),
        }))
      )
    );

  // Location distribution (top 10)
  const locationStats = await db.prisma.job
    .groupBy({
      by: ["location"],
      _count: { id: true },
      orderBy: { _count: { id: "desc" } },
      take: 10,
    })
    .then((groups) =>
      Promise.all(
        groups.map(async (group) => ({
          location: group.location,
          count: group._count.id,
          jobs: await db.prisma.job.findMany({
            where: { location: group.location },
            take: 3,
            orderBy: { title: "asc" },
          }),
        }))
      )
    );

  // Industry distribution
  const industryStats = await db.prisma.job
    .groupBy({
      by: ["industry"],
      _count: { id: true },
      orderBy: { _count: { id: "desc" } },
      where: { industry: { not: null } },
    })
    .then((groups) =>
      Promise.all(
        groups.map(async (group) => ({
          industry: group.industry!,
          count: group._count.id,
          jobs: await db.prisma.job.findMany({
            where: { industry: group.industry },
            take: 3,
            orderBy: { title: "asc" },
          }),
        }))
      )
    );

  return {
    topTags,
    workArrangementStats,
    locationStats,
    industryStats,
  };
}

// Usage example
const prisma = new PrismaClient();
const db = new JobMarketDatabase(prisma);
const insights = await getMarketInsights(db);
```

### Advanced Query Examples

```typescript
// Find jobs with specific skills and flexible work arrangements
async function findFlexibleJobsWithSkills(
  db: JobMarketDatabase,
  skills: string[],
  workArrangements: string[] = ["Vollzeit", "Teilzeit"]
): Promise<Job[]> {
  return await db.prisma.job.findMany({
    where: {
      AND: [
        {
          workArrangement: { in: workArrangements },
        },
        {
          OR: [{ isFullHomeOffice: true }, { isPartialHomeOffice: true }],
        },
        {
          tags: {
            some: {
              tag: {
                name: { in: skills },
              },
            },
          },
        },
      ],
    },
    include: {
      tags: {
        include: {
          tag: true,
        },
      },
    },
    orderBy: [{ tags: { _count: "desc" } }, { company: "asc" }],
  });
}

// Get job recommendations based on tag similarity
async function getJobRecommendations(
  db: JobMarketDatabase,
  jobId: string,
  limit: number = 10
): Promise<Job[]> {
  // Get the tags for the given job
  const jobWithTags = await db.prisma.job.findUnique({
    where: { id: jobId },
    include: {
      tags: {
        include: {
          tag: true,
        },
      },
    },
  });

  if (!jobWithTags) return [];

  const tagIds = jobWithTags.tags.map((jt) => jt.tagId);

  // Find other jobs with similar tags
  return await db.prisma.job.findMany({
    where: {
      AND: [
        { id: { not: jobId } },
        {
          tags: {
            some: {
              tagId: { in: tagIds },
            },
          },
        },
      ],
    },
    include: {
      tags: {
        include: {
          tag: true,
        },
      },
    },
    orderBy: [{ tags: { _count: "desc" } }, { title: "asc" }],
    take: limit,
  });
}
```

## Why Prisma with SQLite?

### Technical Advantages

1. **Type safety**: Compile-time guarantees for all database operations
2. **Developer experience**: Auto-generated TypeScript types and fluent API
3. **Schema migrations**: Version-controlled database schema changes
4. **SQLite reliability**: ACID compliance with file-based simplicity
5. **ORM abstraction**: No raw SQL, focus on application logic

### Development Features

1. **IntelliSense**: Full autocomplete for database queries
2. **Schema validation**: Prisma validates schema before generating client
3. **Migration safety**: Automatic rollback on migration failures
4. **Database browser**: Prisma Studio for data exploration
5. **Multi-database**: Easy switching between SQLite (dev) and PostgreSQL (prod)

### Analytics Capabilities

1. **Fluent queries**: Chainable query builders for complex operations
2. **Relationship handling**: Automatic joins and nested data fetching
3. **Aggregation support**: Built-in grouping and statistical functions
4. **Raw SQL fallback**: Direct SQL when needed for performance
5. **Query optimization**: Prisma generates efficient SQL automatically

## Database Results

### Storage Statistics

- **Jobs table**: 6,200+ job records with complete metadata
- **Tags table**: Hierarchical tag system with categories and groups
- **JobTag table**: Many-to-many relationships linking jobs to skills
- **Database file**: Single SQLite file (~50MB) with full dataset

### Performance Metrics

- **Query response time**: &lt;50ms for tag-based job searches
- **Concurrent users**: Support for multiple dashboard users
- **Data freshness**: Real-time updates with instant reflection
- **Storage efficiency**: Compact SQLite format with automatic optimization

## Integration with Dashboard

### API Layer Implementation

```typescript
import { FastifyInstance } from "fastify";
import { JobMarketDatabase } from "./database";
import { z } from "zod";

const jobSearchSchema = z.object({
  skills: z.array(z.string()).optional(),
  workArrangement: z.string().optional(),
  location: z.string().optional(),
  limit: z.number().min(1).max(100).default(50),
});

export async function createJobApi(
  app: FastifyInstance,
  db: JobMarketDatabase
) {
  // Search jobs by skills and filters
  app.get(
    "/api/jobs/search",
    {
      schema: {
        querystring: jobSearchSchema,
      },
    },
    async (request) => {
      const { skills, workArrangement, location, limit } =
        request.query as z.infer<typeof jobSearchSchema>;

      if (skills && skills.length > 0) {
        return await db.findJobsByTags(skills, {
          workArrangement,
          location,
          limit,
        });
      }

      // Return all jobs with filters
      return await db.prisma.job.findMany({
        where: {
          AND: [
            workArrangement ? { workArrangement } : {},
            location ? { location: { contains: location } } : {},
          ],
        },
        include: {
          tags: {
            include: {
              tag: true,
            },
          },
        },
        take: limit,
        orderBy: { title: "asc" },
      });
    }
  );

  // Get market insights
  app.get("/api/insights/market", async () => {
    return await getMarketInsights(db);
  });

  // Get tag statistics
  app.get("/api/tags/stats", async () => {
    return await db.getTagStatistics();
  });

  // Get jobs by work arrangement
  app.get("/api/jobs/work-arrangement", async () => {
    return await db.getJobsByWorkArrangement();
  });

  // Get job details with tags
  app.get("/api/jobs/:id", async (request) => {
    const { id } = request.params as { id: string };

    return await db.prisma.job.findUnique({
      where: { id },
      include: {
        tags: {
          include: {
            tag: true,
          },
        },
      },
    });
  });
}
```

### Environment Configuration

```bash
# .env
DATABASE_URL="file:./jobs_data.db"
```

```typescript
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}
```

The Prisma-based database layer provides type-safe, efficient data access for our interactive dashboard, enabling complex queries, real-time analytics, and maintainable application code.
